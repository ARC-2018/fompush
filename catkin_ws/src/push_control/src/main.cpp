#include <iostream>
#include <dlfcn.h>
#include <vector>
#include <stdio.h>
#include <unistd.h>
#include <ctime>
#include <math.h>
#include <pthread.h>
#include <fstream>
#include <string>
#include <Eigen/Dense>
#include "gurobi_c++.h"
#include <fstream>
#include <memory>
#include <cstdlib>
#include "pushing.h"
#include <time.h>
#include <iomanip>
#include <sys/time.h>
#include <sys/resource.h>

#include "PracticalSocket/PracticalSocket.h" // For UDPSocket and SocketException
#include "egm.pb.h" // generated by Google protoc.exe
#include "tf2_msgs/TFMessage.h"
#include "tf/LinearMath/Transform.h"

#include <ros/ros.h>
#include "tf/tf.h"
#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include "geometry_msgs/Twist.h"

using namespace abb::egm;
using namespace tf;

//
using namespace std;
using Eigen::MatrixXd;

//Define Global Variables
const int num_ineq_constraints = NUM_INEQ_CONSTRAINTS;
const int num_eq_constraints = NUM_EQ_CONSTRAINTS;
const int num_variables = NUM_VARIABLES;
const int num_constraints = num_ineq_constraints+num_eq_constraints;

pthread_mutex_t nonBlockMutex;

// Define structure to send arguments to thread
typedef struct thread_data{
    MatrixXd  *_q_pusher;
    MatrixXd  *_q_slider;
    MatrixXd  *_dq_slider;
    MatrixXd  *_Target;
    MatrixXd  *_u_control;

} tdata_t;

struct thread_data thread_data_array[1];

// Start Thread
//This thread builds and solves the quadratic program and returns the desired control force
//////////////////////////////////////////////////////////////////////////////
void *rriMain(void *thread_arg)
{

    struct thread_data *my_data;
    my_data = (struct thread_data *) thread_arg;

    //Define variables from argument pointers
    pthread_mutex_lock(&nonBlockMutex);
    MatrixXd *pq_slider = my_data->_q_slider;
    MatrixXd *pdq_slider= my_data->_dq_slider;
    MatrixXd *pq_pusher = my_data->_q_pusher;
    MatrixXd *pTarget = my_data->_Target;
    MatrixXd *pu_control = my_data->_u_control;

    MatrixXd &q_slider = *pq_slider;
    MatrixXd &dq_slider = *pdq_slider;
    MatrixXd &q_pusher = *pq_pusher;
    MatrixXd &Target = *pTarget;
    MatrixXd &u_control = *pu_control;
    pthread_mutex_unlock(&nonBlockMutex);

    //Define local variables
    double fval1;
    double fval2;
    double fval3;
    double t_init;
    double T_des, delta_t, t_ini;
    double step_size = 1.f/100;
    int minIndex, maxCol;
    float min;

    //Define local matrix variables
    MatrixXd fval(3,1);
    MatrixXd _q_slider_(3,1);
    MatrixXd _dq_slider_(3,1);
    MatrixXd _q_pusher_(2,1);
    MatrixXd _Target_(2,1);

    //Define text file string variables
    char Q_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/H.txt";
    char Abar_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/A_bar.txt";
    char Ain_stick_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/Ain_stick.txt";
    char bin_stick_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/bin_stick.txt";
    char Aeq_stick_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/Aeq_stick.txt";
    char beq_stick_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/beq_stick.txt";
    char Ain_up_str[]    = "/home/mcube/cpush/catkin_ws/src/push_control/data/Ain_up.txt";
    char bin_up_str[]    = "/home/mcube/cpush/catkin_ws/src/push_control/data/bin_up.txt";
    char Aeq_up_str[]    = "/home/mcube/cpush/catkin_ws/src/push_control/data/Aeq_up.txt";
    char beq_up_str[]   = "/home/mcube/cpush/catkin_ws/src/push_control/data/beq_up.txt";
    char Ain_down_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/Ain_down.txt";
    char bin_down_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/bin_down.txt";
    char Aeq_down_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/Aeq_down.txt";
    char beq_down_str[] = "/home/mcube/cpush/catkin_ws/src/push_control/data/beq_down.txt";


    //Define object for 3 family of modes
    Push * pStick;
    Push * pUp;
    Push * pDown;

    pStick = new Push (Q_str, Abar_str, Ain_stick_str, bin_stick_str, Aeq_stick_str, beq_stick_str);
    pUp    = new Push (Q_str, Abar_str, Ain_up_str, bin_up_str, Aeq_up_str, beq_up_str);
    pDown  = new Push (Q_str, Abar_str, Ain_down_str, bin_down_str, Aeq_down_str, beq_down_str);

    Push &Stick = *pStick;
    Push &Up = *pUp;
    Push &Down = *pDown;

    //Build optimization models
    Stick.build_model();
    Up.build_model();
    Down.build_model();

    //**********************************************************************
    //************************ Begin Loop **********************************
    //**********************************************************************
    double time = 0;
    double counter = 0;

    // cout<<  "Thread Loop Start"<< endl;

    while(time<50000 && ros::ok())
        {
        if (time==0){t_ini = gettime();}
        time = gettime()- t_ini;
//      T_des = counter*step_size;
//      delta_t = (T_des - time)*1e6;
//      if (delta_t > 0){usleep(delta_t);}
// cout<< " time " << time<<endl;
        

        //Read state of robot and object from shared variables
        pthread_mutex_lock(&nonBlockMutex);
        // cout<<" Thread "<<" q_slider "<<_q_slider_<< " dq_slider" << _dq_slider_<<" q_pusher"<< _q_pusher_<<endl;
        
        _q_slider_ = q_slider;
        _dq_slider_= dq_slider;
        _q_pusher_= q_pusher;
        _Target_= Target;
        pthread_mutex_unlock(&nonBlockMutex);

        //Update and solve optimization models
        Stick.update_model(_q_slider_, _dq_slider_, _q_pusher_,_Target_);
        Up.update_model(_q_slider_, _dq_slider_, _q_pusher_,_Target_);
        Down.update_model(_q_slider_, _dq_slider_, _q_pusher_,_Target_);

        fval1 = Stick.optimize();
        fval2 = Up.optimize();
        fval3 = Down.optimize();

        //Find optimial control input
        fval << fval1, fval2, fval3;
        min = fval.minCoeff(&minIndex, &maxCol); //Find

        //Assign new control input to shared variables
        pthread_mutex_lock(&nonBlockMutex);
        if (minIndex==0){u_control = Stick.delta_u;}
        else if (minIndex==1){  u_control = Up.delta_u;}
        else{   u_control = Down.delta_u;}
        pthread_mutex_unlock(&nonBlockMutex);

        counter++;

        }
    //*********** End Loop **************************************************
    pthread_exit((void*) 0);
}


// helper function
uint32_t GetTickCount(void) 
{
  struct timespec now;
  if (clock_gettime(CLOCK_MONOTONIC, &now))
    return 0;
  return now.tv_sec * 1000 + now.tv_nsec / 1000000;
}


//////////////////////////////////////////////////////////////////////////
// Create a simple robot message
void CreateSensorMessage(EgmSensor* pSensorMessage, float x, float y)
{ 
    static unsigned int sequenceNumber = 0;
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

    EgmCartesian *pc = new EgmCartesian();
    //float z = 0.221;  //pu
    float z = 0.230;  //plywood
    // x = 0.4;
    // y = -0.03;
    // z = 0.25;
    if(x > 0.5) x = 0.5;
    if(x < 0.15) x = 0.15;
    if(y > 0.2) y = 0.2;
    if(y < -0.2) y = -0.2;
    pc->set_x(x*1000);    // convert to robot representation mm
    pc->set_y(y*1000);          
    pc->set_z(z*1000);
    //printf("*********Commands Sent to Robot***********\n");
    //printf("%f %f %f\n", x, y, z);
    //printf("******************************t***********\n");
    EgmQuaternion *pq = new EgmQuaternion();
    pq->set_u0(0);   // need to fill in 
    pq->set_u1(0);
    pq->set_u2(1);
    pq->set_u3(0);
    
    // cout<< "x_send"<<x<<endl;
    //cout<< "y"<<y<<endl;

    EgmPose *pcartesian = new EgmPose();
    pcartesian->set_allocated_orient(pq);
    pcartesian->set_allocated_pos(pc);

    EgmPlanned *planned = new EgmPlanned();
    planned->set_allocated_cartesian(pcartesian);

    pSensorMessage->set_allocated_planned(planned);
}

void CreateSensorMessageEmpty(EgmSensor* pSensorMessage)
{ 
    static unsigned int sequenceNumber = 0;
    EgmHeader* header = new EgmHeader();
    header->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION);
    header->set_seqno(sequenceNumber++);
    header->set_tm(GetTickCount());

    pSensorMessage->set_allocated_header(header);

}


void DisplayRobotMessage(EgmRobot *pRobotMessage, double& x, double& y, double& z)
{
    double x_robot, y_robot, z_robot;
    if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype()  )
    {
        //printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
    x_robot =  pRobotMessage->feedback().cartesian().pos().x();
    y_robot =  pRobotMessage->feedback().cartesian().pos().y();
    z_robot =  pRobotMessage->feedback().cartesian().pos().z();
    
    x = x_robot / 1000;
    y = y_robot / 1000;
    z = z_robot /1000; 
    }
    else
    {
        printf("No header\n");
    }
}

// need mutex to protect
// float object_pose[7];
// bool has_object_pose = false;
// float viconworld_pose[7];
// tf::Transform  vicon_T_object;
// bool has_vicon_to_world = false;
// void tfCallback(const tf_msgs::TFMessage::ConstPtr& msg){
    // string targetTF = "vicon/StainlessSteel/StainlessSteel";
    // 
    // if (msg->transforms[0].child_frame_id == string("/viconworld")){
        // tf::transformMsgToTF(msg->transforms[0].transform, vicon_T_object);
        // 
    // }
    // 
    // else if (msg->transforms[0].child_frame_id == targetTF && has_vicon_to_world){
        // has_object_pose = true;
        // 
        // tf::Transform  vicon_T_object;
        // tf::transformMsgToTF(msg->transforms[0].transform, world_T_vicon);
        // world_T_vicon
    // }
// }

bool getRobotPose(UDPSocket* EGMsock, string& sourceAddress, unsigned short& sourcePort, EgmRobot* pRobotMessage, double& robot_x, double& robot_y, double& robot_z){
    int recvMsgSize;
    const int MAX_BUFFER = 1400;
    char buffer[MAX_BUFFER];
    try{
        recvMsgSize = EGMsock->recvFrom(buffer, MAX_BUFFER-1, sourceAddress, sourcePort);
        if (recvMsgSize < 0)
        {
            printf("Error receive message\n");
        }
        else {
            //printf("Received %d\n", recvMsgSize);
        }

        // deserialize inbound message
        pRobotMessage->ParseFromArray(buffer, recvMsgSize);
        DisplayRobotMessage(pRobotMessage, robot_x, robot_y, robot_z); //Assign tcp position of robot to robot_x, robot_y, robot_z
        return true;
    } catch (SocketException &e) {}
    
    return false;
}

bool getViconPose(MatrixXd& q_slider, TransformListener& listener){
    tf::StampedTransform obj_pose;
    try{
        listener.lookupTransform("map", "vicon/StainlessSteel/StainlessSteel", ros::Time(0), obj_pose);
        tf::Quaternion q = obj_pose.getRotation();
        tf::Matrix3x3 m(q);
        double roll, pitch, yaw;
        m.getRPY(roll, pitch, yaw);
        
        q_slider << obj_pose.getOrigin().getX(), obj_pose.getOrigin().getY()+ 0.018, yaw;
        return true;
    }
    catch (tf::TransformException ex){
       //ROS_ERROR("%s",ex.what());
    }
    return false;
}

bool getViconVel(MatrixXd& dq_slider, TransformListener& listener){
    geometry_msgs::Twist obj_twist;
    try{
        listener.lookupTwist("vicon/StainlessSteel/StainlessSteel", "map", ros::Time(0), ros::Duration(0.5), obj_twist);
        dq_slider << obj_twist.linear.x, obj_twist.linear.y, obj_twist.angular.z;
        return true;
    }
    catch (tf::TransformException ex){
        //ROS_ERROR("%s",ex.what());
    }
    return false;
}

// void* runEGMTread(void* robot){
    // robot->ActivateEGM();
// }
// 
// void startEGM(RobotComm* robot){
    // pthread_t* pThread = new pthread_t();
    // pthread_attr_t attrR;
    // pthread_attr_init(&attrR);
    // pthread_attr_setdetachstate(&attrR, PTHREAD_CREATE_JOINABLE);
    // 
    // pthread_create(pThread, &attrR, runEGMTread, (void*) robot) ;
// }

//********************************************************************
// Main Program
//********************************************************************
int
main(int argc,  char *argv[])
{
    ros::init(argc, argv, "push_control");
    ros::NodeHandle n;
    tf::TransformListener listener;
    //ros::Subscriber sub = n.subscribe("/tf", 1, tfCallback);

    // Declare Matrix variables
    MatrixXd q_pusher(2,1);
    MatrixXd dq_pusher(2,1);
    MatrixXd q_slider(3,1);
    MatrixXd dq_slider(3,1);
    MatrixXd r_cb_b(2,1);
    MatrixXd Cbi(3,3);
    MatrixXd Cbi_T(3,3);
    MatrixXd Target(2,1);
    MatrixXd u_control(4,1);
    MatrixXd vp(2,1);
    MatrixXd ap(5,1);
    MatrixXd _q_slider_(3,1);
    MatrixXd _dq_slider_(3,1);
    MatrixXd smoothed_dq_slider(3,1);
    MatrixXd _q_pusher_(2,1);
    MatrixXd _Target_(2,1);
    MatrixXd _u_control_(4,1);
    MatrixXd vo_des(3,1);
    MatrixXd qo_des(3,1);

    //Define physical parameters
    const double a = 0.09;
    double psi, theta;
    double minIndex, maxCol;
    double dX, dY;
    double fval1, fval2, fval3;
    double t_init;
    double time;
    double T_des, delta_t, t_ini;
    double step_size = 1.f/250;
    double xp, yp, zp;
    double x_tcp, y_tcp, z_tcp;
    double _x_tcp, _y_tcp, _z_tcp;
    double xp_des, yp_des;
    double tcp_width = 0.00475;
    bool has_robot = false;
    bool has_vicon_pos = false;
    bool has_vicon_vel = false;
    double Position_Outputs[2];
    FILE *myFile = NULL;

    //****************************************************************
    //************** Create Thread ****************************
    //****************************************************************
    //Define Mutex
    pthread_mutex_t nonBlockMutex;
    pthread_mutex_init(&nonBlockMutex, NULL);

    //Define Thread
    pthread_t rriThread;
    pthread_attr_t attrR;
    pthread_attr_init(&attrR);
    pthread_attr_setdetachstate(&attrR, PTHREAD_CREATE_JOINABLE);

    //Assign arguments to pass to thread
    thread_data_array[0]._q_pusher = &q_pusher;
    thread_data_array[0]._q_slider = &q_slider;
    thread_data_array[0]._dq_slider = &dq_slider;
    thread_data_array[0]._Target = &Target;
    thread_data_array[0]._u_control = &u_control;
        
    // Create socket and wait for robot's connection
    UDPSocket* EGMsock;
    const int portNumber = 6510;
    string sourceAddress;             // Address of datagram source
    unsigned short sourcePort;        // Port of datagram source

    EGMsock = new UDPSocket(portNumber);
    EgmSensor *pSensorMessage = new EgmSensor();
    EgmRobot *pRobotMessage = new EgmRobot();
    string messageBuffer;
    
    
    //Move the robot to the starting position
    //RobotComm robot(&n, "2");
    //robot.SetSpeed(60, 40);
    
    //robot.SetCartesian(230, 40, 230, 0, 0, 1, 0); //x,y,z (mm), qw, qx,qy,qz
    
    
    //startEGM(&robot);
    
    //Initialize Vicon and robot data collection
        
    int tmp = 0;
    int lv1 = 0;
    double xs_old=0, xs=0,dxs=0;
    double ys_old=0, ys=0,dys=0 ;
    double thetas_old=0, thetas=0, dthetas=0;
    double h1=1.0f/1000;

    // !has_robot ||
    while((!has_robot || !has_vicon_pos || tmp < 3000) && ros::ok())
    //while(ros::ok())
    {
        tmp++;
        //Read robot position
        if(getRobotPose(EGMsock, sourceAddress, sourcePort, pRobotMessage, x_tcp, y_tcp, z_tcp)){
            // cout << " In first loop" << endl;
            has_robot = true;
            //CreateSensorMessageEmpty(pSensorMessage);
            CreateSensorMessage(pSensorMessage,0.23,-0.04);
            pSensorMessage->SerializeToString(&messageBuffer);
            EGMsock->sendTo(messageBuffer.c_str(), messageBuffer.length(), sourceAddress, sourcePort);
        }
        if(getViconPose(q_slider, listener))
            has_vicon_pos = true;
        // if(getViconVel(dq_slider, listener))
            // has_vicon_vel = true;
        xs_old = xs;
        ys_old = ys;
        thetas_old = thetas; 
        
        xs = smooth(q_slider(0), 0.98, xs);
        ys = smooth(q_slider(1), 0.98, ys);
        thetas = smooth(q_slider(2), 0.98, thetas);
        
        dq_slider(0) = (xs-xs_old)/h1;
        dq_slider(1) = (ys-ys_old)/h1;
        dq_slider(2) = (thetas-thetas_old)/h1;
            
        // h1 = 4e3/(1e6);
            
        // if (!has_vicon_pos){
        // xs_old = q_slider(0);
        // ys_old = q_slider(1);
        // thetas_old = q_slider(2);}
        // else{
        // xs_old = xs;
        // ys_old = ys;
        // thetas_old = thetas;
        // }

        // xs     = smooth( q_slider(0),  0.00,  xs);
        // ys     = smooth( q_slider(1),  0.00,  ys);
        // thetas = smooth( q_slider(2),  0.00,  thetas);
        // 
        // dxs = (xs-xs_old)/(h1);
        // dys = (ys-ys_old)/(h1);
        // dthetas = (thetas-thetas_old)/(h1);
        
        // printf("RobotPose %f %f %f\n", x_tcp, y_tcp, z_tcp);
        // printf(" %d %f %f %f %f %f %f %f %f\n", lv1, q_slider(0), q_slider(1), q_slider(2), dq_slider(0), dq_slider(1), dq_slider(2), x_tcp, y_tcp);
        // dq_slider=-dq_slider;
        lv1+=1;
        usleep(4e3);
    }

    // return 0;
    //Read Vicon and Initialize Variables
    theta = q_slider(2);

    Target << .5,-0.040;
    q_pusher(0) = x_tcp + tcp_width*cos(theta);
    q_pusher(1) = y_tcp - tcp_width*sin(theta);
    xp_des = q_pusher(0);
    yp_des =  q_pusher(1);

    //Create Thread
    pthread_create(&rriThread, &attrR, rriMain, (void*) &thread_data_array[0]) ;

    
    for(int i=0;i<1000;i++){
        if(getRobotPose(EGMsock, sourceAddress, sourcePort, pRobotMessage, x_tcp, y_tcp, z_tcp)){
            // cout << " In second loop" << endl;
            has_robot = true;
            CreateSensorMessageEmpty(pSensorMessage);
            //CreateSensorMessage(pSensorMessage,0.4,-0.04);
            pSensorMessage->SerializeToString(&messageBuffer);
            EGMsock->sendTo(messageBuffer.c_str(), messageBuffer.length(), sourceAddress, sourcePort);
        }
        usleep(4e3);
    }
    
    // cout << " Second loop terminated" << endl;
        if(getRobotPose(EGMsock, sourceAddress, sourcePort, pRobotMessage, _x_tcp, _y_tcp, _z_tcp)){
            // cout<< "********************************"<<endl;
            // printf("getRobotPose %f %f %f\n", _x_tcp, _y_tcp, _z_tcp);
            // cout<< "*******************************"<<endl;
            //pSensorMessage->SerializeToString(&messageBuffer);
            //EGMsock->sendTo(messageBuffer.c_str(), messageBuffer.length(), sourceAddress, sourcePort);
            
        }
    
    //usleep(1e6);
    //****************************************************************

    //****************************************************************
    //************** Main Control Loop ****************************
    //****************************************************************
        
        
    double x0 = x_tcp;
    double y0 = y_tcp;
    double psi_des = 0;
    double dx_smooth=0;
    double dy_smooth=0;
    vo_des = dq_slider;
    vp << 0,0;
    
    //usleep(1e6);
    double _x_tcp_old = 0.0;
    
 // cout << " Start Third Loop" << endl;
    for (int i=0;i<15000  && ros::ok();i++){
        // cout << " In Third Loop" << endl;
        if (i==0){t_ini = gettime();}
        // //Get time and set frequency of loop to 250 Hz
        time = gettime()- t_ini;
        // //printf("time:%f\n", time);
        // T_des = i*step_size;
        // delta_t = T_des - time;
        // delta_t = delta_t*1e6;
        //if (delta_t > 0){usleep(delta_t);}

        //**********************  Get State of robot and object from ROS *********************************

        // pthread_mutex_lock(&nonBlockMutex);
       _x_tcp = x_tcp;
       _y_tcp = y_tcp;

       // Use this section for simulation purposes
       if (i % 1==0){
           qo_des = q_slider;
           vo_des = dq_slider;
           // if(getRobotPose(EGMsock, sourceAddress, sourcePort, pRobotMessage, _x_tcp, _y_tcp, _z_tcp)){
            // cout<< "********************************"<<endl;
            // printf("getRobotPose %f %f %f\n", _x_tcp, _y_tcp, _z_tcp);
            // cout<< "*******************************"<<endl;            
        }
        pthread_mutex_lock(&nonBlockMutex);
        // _x_tcp = x_tcp;
        // _y_tcp = y_tcp;

        getViconPose(q_slider, listener);
        // getFilteredVel(dq_slider);
        // getViconVel(dq_slider, listener);
        
        xs_old = xs;
        ys_old = ys;
        thetas_old = thetas; 
        
        xs = smooth(q_slider(0), 0.98, xs);
        ys = smooth(q_slider(1), 0.98, ys);
        thetas = smooth(q_slider(2), 0.98, thetas);
        
        dq_slider(0) = (xs-xs_old)/h1;
        dq_slider(1) = (ys-ys_old)/h1;
        dq_slider(2) = (thetas-thetas_old)/h1;
        
        pthread_mutex_unlock(&nonBlockMutex);
        // cout<< "***************************************************************************************************"<<endl;
        // }
// 
        // pthread_mutex_unlock(&nonBlockMutex);
        // 
        // theta = _q_slider_(2);
        pthread_mutex_lock(&nonBlockMutex);
        q_pusher(0) = _x_tcp;// + tcp_width*cos(theta*1);
        q_pusher(1) = _y_tcp;// + tcp_width*sin(theta*1);
        
        //Assign local variables
        _q_slider_ = q_slider;
        _dq_slider_ = dq_slider*1; //Will need to numerically differentiate this value
        _q_pusher_ = q_pusher;
        _Target_ = Target;
        _u_control_ = u_control;
// 
        pthread_mutex_unlock(&nonBlockMutex);
        //**********************************************************************************
        // xp = _q_pusher_(0);
        // yp = _q_pusher_(1);

        // if (sqrt(pow(xp-Target(0),2)+pow(yp-Target(1),2))>0.05){
            // xp=  xp + step_size*vp(0);
            // xp=  xp + step_size*0.05;
            // yp=  -0.04;// + step_size*vp(1)*1;
            // if(xp-vp(0)<0.001 or yp-vp(1)<0.001)
            // {
              // xp = x_tcp;//vp(0);
              // yp = y_tcp;//p(1);
              // xp = x_tcp+ (step_size)*0.05;// + (1/step_size)*time*0.05;
              // cout<<"Test Value"<<x0 + (step_size)*time*0.05<<endl;
              // yp = y_tcp;
              // }

            // xp_des=xp;
            // yp_des=yp;
            // printf("vp %f %f\n", vp(0), vp(1));
        // }
        // else
            // {cout<< "Target Reached within tolerance"<<endl; }
         // cout << "Count: " << i << " Difference: " << _x_tcp_old - _x_tcp << endl; 
        // _x_tcp_old = _x_tcp;
        // cout<< " u_control " <<_u_control_;
        // cout<< " cos(theta*1) " << cos(theta*1) << " tcp_width " <<tcp_width;

        //wait
        if (time<=1)
          {x_tcp = x_tcp;}
        else
        {

        printf(" %f %f %f %f %f %f %f %f %f\n", time, q_slider(0), q_slider(1), q_slider(2), dq_slider(0), dq_slider(1), dq_slider(2), x_tcp, y_tcp);
        
        // Determine desired velocity of pusher
        ap = inverse_dynamics2(_q_pusher_, q_slider, dq_slider, _u_control_, x_tcp, y_tcp, qo_des, vo_des);
        
        qo_des(0) = ap(2);
        qo_des(1) = ap(3);
        qo_des(2) = ap(4);
        vo_des(0) = ap(5);
        vo_des(1) = ap(6);
        vo_des(2) = ap(7);
        // psi_des = h*ap(9)
        
        // cout << " vo_des " << vo_des << endl;
        // cout << " dq_slider " << dq_slider << endl;

          double h = 1.0f/1000;
          // vp(0) = vp(0) + h*ap(0);
          // vp(1) = vp(1) + h*ap(1);
          // cout << " vp "  << vp << endl;
          // cout << " ap "  << ap << endl;
          x_tcp = x_tcp + 1*h*ap(0);// + 1*h*h*ap(0);
          y_tcp = y_tcp + 1*h*ap(1);// + 1*h*h*ap(1);
          
          _x_tcp = _x_tcp;// + h*ap(0);// + 0*h*h*ap(0);
          _y_tcp = _y_tcp;// + h*ap(1);

          }
          //vp(0)*(1)/1000.0;
          // y_tcp = vp(1);//y_tcp + vp(1)*1/1000.0;
          
        Position_Outputs[0] = x_tcp;
        Position_Outputs[1] = _x_tcp;
    // cout<< " x_tcp " << x_tcp << endl;
    // cout<< " y_tcp " << y_tcp << endl;
        CreateSensorMessage(pSensorMessage, x_tcp, y_tcp);
        // 
        pSensorMessage->SerializeToString(&messageBuffer);
        EGMsock->sendTo(messageBuffer.c_str(), messageBuffer.length(), sourceAddress, sourcePort);
        //printf("Sent %lu\n", messageBuffer.length());
        usleep(1000);
    }
    
    (void) pthread_join(rriThread, NULL);
    //cout<< "End of Program"<<endl;

    return 0;
}
